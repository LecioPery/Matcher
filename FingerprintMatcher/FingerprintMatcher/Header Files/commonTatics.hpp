#ifndef COMMON_TATICS__
#define COMMON_TATICS__

#include <vector>

typedef std::vector<float> VectorFloat;

template<typename T>
inline std::vector<T> operator+=( std::vector<T> &v1, std::vector<T> &v2 )
{
	
	std::vector<T> result;
	int iterator;
	
	if ( v1.size() != v2.size() )
	{
		
		std::cout << "Error: a sum between vectors from different sizes was attempted." << std::endl;
		system( "PAUSE" );
		return result;
		
	}
	
	for (iterator = 0; iterator < v1.size(); iterator++)
	{
		
		/* As long as "+" is defined in "T + T;" */
		v1.at(iterator) = v1.at(iterator) + v2.at(iterator);
		//result.push_back( v1.at( iterator ) + v2.at( iterator ) );
		
	}
	return result;
	
	/**
	 * Precision demonstrated using VStudio's Debugger, windows calc.exe,
	 * 31-sized feature vector from a fingerprint experiment and patience.
	 *		- With LoV3, Lec1vs P3rY the Júnior!
	 *    result         operand1         operand2         error
	 * 00 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 01 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 02 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 03 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 04 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 05 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 06 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 07 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 08 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 09 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 10 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 11 0.0000000000 - (0.00000000000 + 0.00000000000) = 0.000000000000
	 * 12 0.0105263162 - (0.00526315812 + 0.00526315812) = -0.00000000004
	 * 13 0.1315789520 - (0.06842105090 + 0.06315789370) = 0.000000007400
	 * 14 0.3105263110 - (0.16315789500 + 0.14736841600) = 0.000000000000
	 * 15 0.6105263230 - (0.28947368300 + 0.32105264100) = -0.00000000100
	 * 16 0.8947368260 - (0.43157893400 + 0.46315789200) = 0.000000000000
	 * 17 1.2000000500 - (0.58421051500 + 0.61578947300) = 0.000000062000
	 * 18 1.5105263000 - (0.74736839500 + 0.76315790400) = 0.000000001000
	 * 19 1.6842105400 - (0.83684212000 + 0.84736841900) = 0.000000001000
	 * 20 1.8421052700 - (0.92631578400 + 0.91578948500) = 0.000000001000
	 * 21 1.8894736800 - (0.94736844300 + 0.94210523400) = 0.000000003000
	 * 22 1.9473683800 - (0.96842104200 + 0.97894734100) = -0.00000000300
	 * 23 1.9894737000 - (0.99473685000 + 0.99473685000) = 0.000000000000
	 * 24 1.9947369100 - (1.00000000000 + 0.99473685000) = 0.000000060000
	 * 25 2.0000000000 - (1.00000000000 + 1.00000000000) = 0.000000000000
	 * 26 2.0000000000 - (1.00000000000 + 1.00000000000) = 0.000000000000
	 * 27 2.0000000000 - (1.00000000000 + 1.00000000000) = 0.000000000000
	 * 28 2.0000000000 - (1.00000000000 + 1.00000000000) = 0.000000000000
	 * 29 2.0000000000 - (1.00000000000 + 1.00000000000) = 0.000000000000
	 * 30 2.0000000000 - (1.00000000000 + 1.00000000000) = 0.000000000000
	 * The error is the module of the vector ( result - (operand1 + operand2) ):
	 *		Error = 8.6722324692088368855369291620427e-8
	**/
	
};

template<typename T, typename S>
std::vector<T> operator/=( std::vector<T>& v, S scalar )
{
	
	std::vector<T> result;
	int i;
	
	for (i = 0; i < v.size(); i++)
	{
		v.at(i) = v.at(i) / scalar;
	}
	return result;

	/** No precision check. Take previous example for reliability. */
	
}

#endif